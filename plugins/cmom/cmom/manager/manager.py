#!/usr/bin/env python

import os
import json
import shutil
from collections import Mapping

from cloudify import ctx
from cloudify.decorators import operation
from cloudify.state import ctx_parameters as inputs
from cloudify.manager import download_resource_from_manager

from ..common import (
    execute_and_log,
    INSTALL_RPM,
    CA_CERT,
    CA_KEY
)

INSTALL_RPM_PATH = '/tmp/cloudify-manager-install.rpm'
CONFIG_PATH = '/etc/cloudify/config.yaml'
EXTERNAL_KEY_PATH = '/etc/cloudify/ssl/cloudify_external_key.pem'
EXTERNAL_CERT_PATH = '/etc/cloudify/ssl/cloudify_external_cert.pem'


def _download_rpm():
    ctx.logger.info('Downloading Cloudify Manager installation RPM...')
    download_resource_from_manager(
        resource_path=INSTALL_RPM,
        logger=ctx.logger,
        target_path=INSTALL_RPM_PATH
    )
    ctx.logger.info('Install RPM downloaded successfully')


def _install_rpm():
    ctx.logger.info('Installing RPM...')
    execute_and_log(['sudo', 'rpm', '-i', INSTALL_RPM_PATH])

    os.remove(INSTALL_RPM_PATH)
    ctx.logger.info('RPM installed successfully')


def _dict_merge(dct, merge_dct):
    """ Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    Taken from: https://gist.github.com/angstwad/bf22d1822c38a92ec0a9
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k, v in merge_dct.iteritems():
        if (k in dct and isinstance(dct[k], dict)
                and isinstance(merge_dct[k], Mapping)):
            _dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]


def _dump_configuration():
    """
    Dump the config from the node properties to /etc/cloudify/config.yaml
    """
    # The config file is expected to be YAML, but it should still be able
    # to read a json file
    ctx.logger.info('Dumping configuration from the inputs...')
    config = ctx.instance.runtime_properties['config']
    with open(CONFIG_PATH, 'w') as f:
        json.dump(config, f)


def _install_manager():
    ctx.logger.info('Installing Cloudify Manager...')

    execute_and_log(['cfy_manager', 'install'], clean_env=True)
    ctx.logger.info('Cloudify Manager installed successfully')


def _update_runtime_properties():
    """
    Update the information relevant for later clustering needs in the
    runtime properties, so that it would be easily accessible by other nodes
    """
    # Override any values in `config` with values in `additional_config`
    config = inputs['config']
    additional_config = inputs['additional_config']
    _dict_merge(config, additional_config)

    ctx.instance.runtime_properties['config'] = config
    ctx.instance.update()
    ctx.logger.debug('Updated {0}: {1}'.format(ctx.instance.id, config))


def _remove_manager():
    ctx.logger.info('Uninstalling Cloudify Manager...')
    execute_and_log(['cfy_manager', 'remove', '--force'])


def _uninstall_rpm():
    ctx.logger.info('Removing RPM...')
    execute_and_log(['yum', 'remove', '-y', 'cloudify-manager-install'])


def _download_ca_cert_and_key():
    """
    Download CA cert and key from the Tier 2 fileserver
    """
    ctx.logger.info('Downloading certificates to a local path...')
    ca_cert = download_resource_from_manager(
        resource_path=CA_CERT,
        logger=ctx.logger
    )
    ca_key = download_resource_from_manager(
        resource_path=CA_KEY,
        logger=ctx.logger
    )
    return ca_cert, ca_key


def _copy_external_cert_and_key():
    ctx.logger.info('Copying external cert and key...')

    home_dir = os.path.expanduser('~')
    external_cert = os.path.join(home_dir, 'external_cert.pem')
    external_key = os.path.join(home_dir, 'external_key.pem')
    shutil.copy(EXTERNAL_CERT_PATH, external_cert)
    shutil.copy(EXTERNAL_KEY_PATH, external_key)

    ssl_inputs = inputs['config'].setdefault('ssl_inputs', {})

    # These values will be dumped with the rest of the configuration
    ssl_inputs['external_cert_path'] = external_cert
    ssl_inputs['external_key_path'] = external_key


def _generate_external_cert_and_key():
    ca_cert, ca_key = _download_ca_cert_and_key()

    # Need to create the `ssl` folder; it's not generated by default
    ssl_dir = '/etc/cloudify/ssl'
    execute_and_log(['sudo', 'mkdir', ssl_dir])

    manager_conf = inputs['config']['manager']
    ctx.logger.info('Generation new external certificate...')
    execute_and_log([
        'cfy_manager', 'create-external-certs',
        '--private-ip', manager_conf['private_ip'],
        '--public-ip', manager_conf['public_ip'],
        '--sign-cert', ca_cert,
        '--sign-key', ca_key
    ])
    _copy_external_cert_and_key()
    # Delete the ssl dir; it will be created by the installation
    execute_and_log(['sudo', 'rm', '-rf', ssl_dir])


@operation
def install_rpm(**_):
    """
    Install the Cloudify Manager install RPM and set the runtime properties
    to include the entire manager config
    """
    _download_rpm()
    _install_rpm()
    _generate_external_cert_and_key()
    _update_runtime_properties()


@operation
def install_manager(**_):
    _dump_configuration()
    _install_manager()


@operation
def delete(**_):
    _remove_manager()
    _uninstall_rpm()
