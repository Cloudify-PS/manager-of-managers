#!/usr/bin/env python

import os
import json
import shutil
from collections import Mapping

from cloudify import ctx
from cloudify.decorators import operation
from cloudify.state import ctx_parameters as inputs
from cloudify.exceptions import CommandExecutionException
from cloudify.manager import download_resource_from_manager

from ..common import (
    execute_and_log,
    INSTALL_RPM,
    CA_CERT,
    CA_KEY
)

INSTALL_RPM_PATH = '/tmp/cloudify-manager-install.rpm'
CONFIG_PATH = '/etc/cloudify/config.yaml'
EXTERNAL_KEY_PATH = '/etc/cloudify/ssl/cloudify_external_key.pem'
EXTERNAL_CERT_PATH = '/etc/cloudify/ssl/cloudify_external_cert.pem'


def _download_rpm():
    ctx.logger.info('Downloading Cloudify Manager installation RPM...')
    _download_file(INSTALL_RPM, target=INSTALL_RPM_PATH)
    ctx.logger.info('Install RPM downloaded successfully')


def _install_rpm():
    ctx.logger.info('Installing RPM...')
    execute_and_log(['sudo', 'rpm', '-i', INSTALL_RPM_PATH])

    os.remove(INSTALL_RPM_PATH)
    ctx.logger.info('RPM installed successfully')


def _dict_merge(dct, merge_dct):
    """ Recursive dict merge. Inspired by :meth:``dict.update()``, instead of
    updating only top-level keys, dict_merge recurses down into dicts nested
    to an arbitrary depth, updating keys. The ``merge_dct`` is merged into
    ``dct``.
    Taken from: https://gist.github.com/angstwad/bf22d1822c38a92ec0a9
    :param dct: dict onto which the merge is executed
    :param merge_dct: dct merged into dct
    :return: None
    """
    for k, v in merge_dct.iteritems():
        if (k in dct and isinstance(dct[k], dict)
                and isinstance(merge_dct[k], Mapping)):
            _dict_merge(dct[k], merge_dct[k])
        else:
            dct[k] = merge_dct[k]


def _dump_configuration():
    """
    Dump the config from the node properties to /etc/cloudify/config.yaml
    """
    # The config file is expected to be YAML, but it should still be able
    # to read a json file
    ctx.logger.info('Dumping configuration from the inputs...')
    config = ctx.instance.runtime_properties['config']
    with open(CONFIG_PATH, 'w') as f:
        json.dump(config, f)


def _install_manager():
    ctx.logger.info('Installing Cloudify Manager...')

    execute_and_log(['cfy_manager', 'install'], clean_env=True)
    ctx.logger.info('Cloudify Manager installed successfully')


def _update_runtime_properties():
    """
    Update the information relevant for later clustering needs in the
    runtime properties, so that it would be easily accessible by other nodes
    """
    # Override any values in `config` with values in `additional_config`
    config = inputs['config']
    additional_config = inputs['additional_config']
    _dict_merge(config, additional_config)

    ctx.instance.runtime_properties['config'] = config
    ctx.instance.update()
    ctx.logger.debug('Updated {0}: {1}'.format(ctx.instance.id, config))


def _remove_manager():
    ctx.logger.info('Uninstalling Cloudify Manager...')
    execute_and_log(['cfy_manager', 'remove', '--force'])


def _uninstall_rpm():
    ctx.logger.info('Removing RPM...')
    execute_and_log(['yum', 'remove', '-y', 'cloudify-manager-install'])


def _certs_dir():
    return os.path.join(os.path.expanduser('~'), 'certificates')


def _download_ca_cert_and_key():
    """
    Download CA cert and key from the Tier 2 fileserver
    """
    ctx.logger.info('Downloading certificates to a local path...')
    ca_cert = os.path.join(_certs_dir(), CA_CERT)
    ca_key = os.path.join(_certs_dir(), CA_KEY)
    _download_file(CA_CERT, target=ca_cert)
    _download_file(CA_KEY, target=ca_key)
    return ca_cert, ca_key


def _copy_external_cert_and_key():
    ctx.logger.info('Copying external cert and key...')

    external_cert = os.path.join(_certs_dir(), 'external_cert.pem')
    external_key = os.path.join(_certs_dir(), 'external_key.pem')
    shutil.copy(EXTERNAL_CERT_PATH, external_cert)
    shutil.copy(EXTERNAL_KEY_PATH, external_key)

    ssl_inputs = inputs['config'].setdefault('ssl_inputs', {})

    # These values will be dumped with the rest of the configuration
    ssl_inputs['external_cert_path'] = external_cert
    ssl_inputs['external_key_path'] = external_key


def _generate_external_cert_and_key():
    ca_cert, ca_key = _download_ca_cert_and_key()

    # Need to create the `ssl` folder; it's not generated by default
    ssl_dir = '/etc/cloudify/ssl'
    execute_and_log(['sudo', 'mkdir', ssl_dir])

    manager_conf = inputs['config']['manager']
    ctx.logger.info('Generating new external certificate...')
    execute_and_log([
        'cfy_manager', 'create-external-certs',
        '--private-ip', manager_conf['private_ip'],
        '--public-ip', manager_conf['public_ip'],
        '--sign-cert', ca_cert,
        '--sign-key', ca_key
    ])
    _copy_external_cert_and_key()
    # Delete the ssl dir; it will be created by the installation
    execute_and_log(['sudo', 'rm', '-rf', ssl_dir])


def _set_ca_cert_in_cli_profile():
    """
    Set the CA cert in the CLI profile, instead of the external cert.
    This is because we're generating the external cert ourselves and signing
    it with the CA cert, but then in order to verify it (say, when using
    CLI, which uses requests under the hood). In order to use the external
    cert, we'd need to
    """
    ca_cert = os.path.join(_certs_dir(), CA_CERT)
    set_cmd = ['cfy', 'profiles', 'set', '-c', ca_cert]
    execute_and_log(set_cmd, clean_env=True)
    execute_and_log(['sudo', '-u', 'root'] + set_cmd, clean_env=True)


def _download_file(path, target=None):
    """
    Download a file that was put in the Tier 2 manager's file server,
    under a DEP_ID folder
    """
    file_name = os.path.basename(path)
    remote_path = os.path.join(ctx.deployment.id, file_name)
    return download_resource_from_manager(
        remote_path,
        target_path=target,
        logger=ctx.logger
    )


def _execute_scripts():
    ctx.logger.info('Executing post-install scripts...')
    for script in inputs['scripts']:
        script_path = _download_file(script)
        execute_and_log(['chmod', '+x', script_path])

        script_name = os.path.basename(script)
        ctx.logger.info('Now running: {0}...'.format(script_name))
        try:
            execute_and_log([script_path])
        except CommandExecutionException as e:
            ctx.logger.warning(
                'Failed running script: {0}'.format(script_name)
            )
            ctx.logger.warning('Error: {0}'.format(e.error))


def _download_files():
    ctx.logger.info('Downloading files...')
    for item in inputs['files']:
        _download_file(item['src'], target=item['dst'])


@operation
def install_rpm(**_):
    """
    Install the Cloudify Manager install RPM and set the runtime properties
    to include the entire manager config
    """
    _download_rpm()
    _install_rpm()

    os.mkdir(_certs_dir())

    _generate_external_cert_and_key()
    _update_runtime_properties()


@operation
def install_manager(**_):
    _dump_configuration()
    _install_manager()
    _set_ca_cert_in_cli_profile()
    _download_files()
    _execute_scripts()


@operation
def delete(**_):
    _remove_manager()
    _uninstall_rpm()
